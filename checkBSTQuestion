题目说明：

给定一个二叉树，判断它是否是合法的二叉查找树(BST)

一棵BST定义为：

  1、节点的左子树中的值要严格小于该节点的值。
  2、节点的右子树中的值要严格大于该节点的值。
  3、左右子树也必须是二叉查找树。
  4、一个节点的树也是二叉查找树。
  
样例：
一个例子：

  2
 / \
1   4
   / \
  3   5
上述这棵二叉树序列化为 {2,1,4,#,#,3,5}.

这个题目可以用分治递归的方法解决，一个树是二叉树的条件就是它的左子树是二叉树且它的右子树是二叉树。

这其中需要注意的地方在于，左子树中的值要严格小于该节点的值，右子树的值要严格大于该节点的值。所以在判断子树时需要把当前节点的值作为参数传入。

因此，程序至少有三个参数，当前节点，以及最大值，最小值。注意，这里需要传入两个参数，因为子树的取值范围中同时包括了上界和下界。

此时，在初始化的时候我选择了Integer.MAX_VALUE作为最大值，Integer.MIN_VALUE作为最小值。但是如果树结构中也包括这两个数字的话（测试用例中确实也包括），
那么就需要判断当前的这个max的上界到底是来自初始化的值还是来自树自身。所以我设立了一个标志，只是一种解决方法供大家参考。
